NockClass containing shared info (battery for resolving arms, location, drivers,
    etc) -- to be kept on NockObject. Better sharing. Objects keep at least a
NockClass and a (lazy) FineCheck. FineCheck tells you whether another candidate
core/object can grab a copy of your NockClass.

add Location objects to fine steps, check those before battery-and-fragment

we don't need a fine for edits, because location gives you enough information to
answer editableAxis

kind of map that is one-thing-then-a-hashmap, for use in Registration

REFLECTION
  We can't load user-supplied classes from the generated native images.
  Jet configuration can be un-static, for sure, but it has to select from
  pre-existing implementation node classes. IE, AddNode has to baked into the
  native image, but someone can tell that image "this is how you match an add,
  use your baked in AddNode."

Jet hot Dashboard
  on boot, need to iterate through whole dashboard and discover from hot
  on initial registry find, check hot dashboard first

Registry information is eternal. One canonical. Null for unregistered batteries.

Transient, cacheable information about batteries -- this will be NockBattery
  keep in weak map and on cellmeta
  clear when invalidating dashboard assumption

  registry (also contains sha, since permanent)
  sha
  last located core with fine check
  reference to dashboard assumption

put transferToInterpreters in the various places where RegistrationNodes replace();

Fast
  test by jetting dec/add and running large mul

Test CellMeta caching (w/edit)

Memo
  with One Big Guava Cache
  and tests
Slog
  tests can capture logs right?
Stack Hints

Step through some nock in a debugger

Command line nock interpreter (with native-image)

Wish

Boot a ride pill
  mostly this is a lot of jetting

Command line hoon interpreter (with native-image)
